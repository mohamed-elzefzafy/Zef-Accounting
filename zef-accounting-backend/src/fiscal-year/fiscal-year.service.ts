// import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
// import { InjectRepository } from '@nestjs/typeorm';
// import { Repository } from 'typeorm';
// import { FiscalYearEntity } from './entities/fiscal-year.entity';
// import { CreateFiscalYearDto } from './dto/create-fiscal-year.dto';
// import { CloseFiscalYearDto } from './dto/close-fiscal-year.dto';
// import { UserEntity } from 'src/users/entities/user.entity';
// import { JournalEntriesService } from 'src/journal-entries/journal-entries.service';

// @Injectable()
// export class FiscalYearService {
//   constructor(
//     @InjectRepository(FiscalYearEntity)
//     private readonly fiscalYearRepo: Repository<FiscalYearEntity>,
//   ) {}

//   async create(dto: CreateFiscalYearDto): Promise<FiscalYearEntity> {
//     const exists = await this.fiscalYearRepo.findOne({ where: { year: dto.year } });
//     if (exists) {
//       throw new BadRequestException(`Fiscal year ${dto.year} already exists`);
//     }

//     const fiscalYear = this.fiscalYearRepo.create(dto);
//     return this.fiscalYearRepo.save(fiscalYear);
//   }

//   async findAll(): Promise<FiscalYearEntity[]> {
//     return this.fiscalYearRepo.find({ order: { year: 'ASC' } });
//   }

//   async findOne(year: number): Promise<FiscalYearEntity> {
//     const fy = await this.fiscalYearRepo.findOne({ where: { year } });
//     if (!fy) throw new NotFoundException(`Fiscal year ${year} not found`);
//     return fy;
//   }

//   async close(dto: CloseFiscalYearDto, user: UserEntity): Promise<FiscalYearEntity> {
//     const fy = await this.findOne(dto.year);

//     if (fy.isClosed) {
//       throw new BadRequestException(`Fiscal year ${dto.year} is already closed`);
//     }

//     fy.isClosed = true;
//     fy.closedAt = new Date();
//     fy.closedBy = user;

//     return this.fiscalYearRepo.save(fy);
//   }
// }


// import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
// import { InjectRepository } from '@nestjs/typeorm';
// import { Repository } from 'typeorm';
// import { CreateFiscalYearDto } from './dto/create-fiscal-year.dto';
// import { FiscalYearEntity } from './entities/fiscal-year.entity';

// @Injectable()
// export class FiscalYearService {
//   constructor(
//     @InjectRepository(FiscalYearEntity)
//     private readonly fiscalYearRepo: Repository<FiscalYearEntity>,
//   ) {}

//   // ÿ•ŸÜÿ¥ÿßÿ° ÿ≥ŸÜÿ© ŸÖÿßŸÑŸäÿ© ÿ¨ÿØŸäÿØÿ©
//   async create(dto: CreateFiscalYearDto) {
//     const existing = await this.fiscalYearRepo.findOne({ where: { year: dto.year } });
//     if (existing) {
//       throw new BadRequestException(`Fiscal year ${dto.year} already exists`);
//     }

//     const fiscalYear = this.fiscalYearRepo.create({
//       year: dto.year,
//       isClosed: false,
//     });

//     return this.fiscalYearRepo.save(fiscalYear);
//   }

//   // ÿ¨ŸÑÿ® ŸÉŸÑ ÿßŸÑÿ≥ŸÜŸàÿßÿ™ ÿßŸÑŸÖÿßŸÑŸäÿ©
//   async findAll() {
//     return this.fiscalYearRepo.find({ order: { year: 'ASC' } });
//   }

//   // ÿ¨ŸÑÿ® ÿ≥ŸÜÿ© ŸÖÿßŸÑŸäÿ© ŸÖÿπŸäŸÜÿ©
//   async findOne(year: number) {
//     const fiscalYear = await this.fiscalYearRepo.findOne({ where: { year } });
//     if (!fiscalYear) {
//       throw new NotFoundException(`Fiscal year ${year} not found`);
//     }
//     return fiscalYear;
//   }

//   // ŸÇŸÅŸÑ ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ©
//   async closeYear(year: number, userId: string) {
//     const fiscalYear = await this.findOne(year);

//     if (fiscalYear.isClosed) {
//       throw new BadRequestException(`Fiscal year ${year} is already closed`);
//     }

//     fiscalYear.isClosed = true;
//     fiscalYear.closedAt = new Date();
//     fiscalYear.closedBy = userId;

//     return this.fiscalYearRepo.save(fiscalYear);
//   }

//   // ŸÅÿ™ÿ≠ ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ© (ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑŸÇŸÅŸÑ)
//   async openYear(year: number) {
//     const fiscalYear = await this.findOne(year);

//     if (!fiscalYear.isClosed) {
//       throw new BadRequestException(`Fiscal year ${year} is already open`);
//     }

//     fiscalYear.isClosed = false;
//     fiscalYear.closedAt = null;
//     fiscalYear.closedBy = null;

//     return this.fiscalYearRepo.save(fiscalYear);
//   }

//   // ÿ¨ŸÑÿ® ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ© (ÿ£ÿ≠ÿØÿ´ ÿ≥ŸÜÿ© ÿ∫Ÿäÿ± ŸÖŸÇŸÅŸàŸÑÿ©)
//   async getCurrentYear() {
//     const fiscalYear = await this.fiscalYearRepo.findOne({
//       where: { isClosed: false },
//       order: { year: 'DESC' },
//     });

//     if (!fiscalYear) {
//       throw new NotFoundException('No active fiscal year found');
//     }

//     return fiscalYear;
//   }
// }



import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Between, DeepPartial, Repository ,DataSource} from 'typeorm';
import {  FiscalYearEntity } from './entities/fiscal-year.entity';
import { CreateFiscalYearDto } from './dto/create-fiscal-year.dto';
import { JournalEntryEntity, JournalEntryLineEntity } from 'src/journal-entries/entities/journal-entry.entity';
import { AccountEntity, AccountType } from 'src/chart/entities/chart.entity';
import { UserEntity } from 'src/users/entities/user.entity';

@Injectable()
export class FiscalYearService {
  constructor(
    @InjectRepository(FiscalYearEntity)
    private readonly fiscalYearRepository: Repository<FiscalYearEntity>,
        @InjectRepository(JournalEntryEntity)
        private readonly journalEntryRepository: Repository<JournalEntryEntity>,
              @InjectRepository(JournalEntryLineEntity)
        private readonly journalEntryLineRepository: Repository<JournalEntryLineEntity>,
            @InjectRepository(AccountEntity)
            private readonly accountRepository: Repository<AccountEntity>,

                @InjectRepository(UserEntity)
    private readonly userRepositry: Repository<UserEntity>,
           private readonly dataSource: DataSource,  
  ) {}

  async create(dto: CreateFiscalYearDto) {
    const existing = await this.fiscalYearRepository.findOne({ where: { year: dto.year } });
    if (existing) {
      throw new BadRequestException(`Fiscal year ${dto.year} already exists`);
    }

    const fiscalYear = this.fiscalYearRepository.create({
      year: dto.year,
      isClosed: false,
    });

    return this.fiscalYearRepository.save(fiscalYear);
  }

  async findAll() {
    return this.fiscalYearRepository.find({ order: { year: 'ASC' } });
  }

  async findOne(year: number) {
    const fiscalYear = await this.fiscalYearRepository.findOne({ where: { year } });
    if (!fiscalYear) {
      throw new NotFoundException(`Fiscal year ${year} not found`);
    }
    return fiscalYear;
  }

  // async closeYear(year: number, userId: string) {
  //   const fiscalYear = await this.findOne(year);

  //   if (fiscalYear.isClosed) {
  //     throw new BadRequestException(`Fiscal year ${year} is already closed`);
  //   }

  //   fiscalYear.isClosed = true;
  //   fiscalYear.closedAt = new Date();
  //   fiscalYear.closedBy = userId;

  //   return this.fiscalYearRepo.save(fiscalYear);
  // }

  // async openYear(year: number) {
  //   const fiscalYear = await this.findOne(year);

  //   if (!fiscalYear.isClosed) {
  //     throw new BadRequestException(`Fiscal year ${year} is already open`);
  //   }

  //   fiscalYear.isClosed = false;
  //   fiscalYear.closedAt = null;
  //   fiscalYear.closedBy = null;

  //   return this.fiscalYearRepo.save(fiscalYear);
  // }

  async getCurrentYear() {
    const fiscalYear = await this.fiscalYearRepository.findOne({
      where: { isClosed: false },
      order: { year: 'DESC' },
    });

    if (!fiscalYear) {
      throw new NotFoundException('No active fiscal year found');
    }

    return fiscalYear;
  }



    // üìå ÿ•ŸÇŸÅÿßŸÑ ÿßŸÑÿ≥ŸÜÿ©
  // async closeYear(year: number) {
  //   const fiscalYear = await this.fiscalYearRepo.findOne({ where: { year } });
  //   if (!fiscalYear) throw new NotFoundException(`Fiscal year ${year} not found`);
  //   if (fiscalYear.isClosed) {
  //     throw new BadRequestException(`Fiscal year ${year} already closed`);
  //   }

  //   const start = new Date(`${year}-01-01`);
  //   const end = new Date(`${year}-12-31`);

  //   const entries = await this.journalEntryRepository.find({
  //     where: { date: Between(start, end) },
  //     relations: ['entries', 'entries.account'],
  //   });

  //   if (!entries.length) {
  //     throw new NotFoundException(`No journal entries found for year ${year}`);
  //   }

  //   let totalRevenue = 0;
  //   let totalExpense = 0;

  //   for (const entry of entries) {
  //     for (const line of entry.entries) {
  //       if (line.account.type === 'Revenue') {
  //         totalRevenue += line.credit - line.debit;
  //       }
  //       if (line.account.type === 'Expense') {
  //         totalExpense += line.debit - line.credit;
  //       }
  //     }
  //   }

  //   const income = totalRevenue - totalExpense;

  //   // ŸÜÿ¨Ÿäÿ® ÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿ£ÿ≥ÿßÿ≥Ÿäÿ©
  //   const incomeSummary = await this.accountRepository.findOneByOrFail({
  //     name: 'income_summary',
  //   });
  //   const retainedEarnings = await this.accountRepository.findOneByOrFail({
  //     name: 'retained_earnings',
  //   });

  //   // ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
  //   const closingEntry = this.journalEntryRepository.create({
  //     date: end,
  //     description: `Closing entry for year ${year}`,
  //     entries: [
  //       this.journalEntryLineRepository.create({
  //         account: incomeSummary,
  //         debit: totalRevenue,
  //         credit: 0,
  //       }),
  //       this.journalEntryLineRepository.create({
  //         account: incomeSummary,
  //         debit: 0,
  //         credit: totalExpense,
  //       }),
  //       income >= 0
  //         ? this.journalEntryLineRepository.create({
  //             account: retainedEarnings,
  //             debit: 0,
  //             credit: income,
  //           })
  //         : this.journalEntryLineRepository.create({
  //             account: retainedEarnings,
  //             debit: -income,
  //             credit: 0,
  //           }),
  //     ],
  //   });

  //   await this.journalEntryRepository.save(closingEntry);

  //   fiscalYear.isClosed = true;
  //   fiscalYear.closedAt = new Date();
  //   await this.fiscalYearRepo.save(fiscalYear);

  //   return { message: 'Year closed successfully', year, income };
  // }

//   async closeYear(year: number) {
//   const fiscalYear = await this.fiscalYearRepo.findOne({ where: { year } });
//   if (!fiscalYear) throw new NotFoundException(`Fiscal year ${year} not found`);
//   if (fiscalYear.isClosed) {
//     throw new BadRequestException(`Fiscal year ${year} already closed`);
//   }

//   const start = new Date(`${year}-01-01`);
//   const end = new Date(`${year}-12-31`);

//   const entries = await this.journalEntryRepository.find({
//     where: { date: Between(start, end) },
//     relations: ['entries', 'entries.account'],
//   });

//   if (!entries.length) {
//     throw new NotFoundException(`No journal entries found for year ${year}`);
//   }

//   let totalRevenue = 0;
//   let totalExpense = 0;

//   for (const entry of entries) {
//     for (const line of entry.entries) {
//       if (line.account.type === 'Revenue') {
//         totalRevenue += line.credit - line.debit;
//       }
//       if (line.account.type === 'Expense') {
//         totalExpense += line.debit - line.credit;
//       }
//     }
//   }

//   const income = totalRevenue - totalExpense;

//   // ŸÜÿ¨Ÿäÿ® ÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿ£ÿ≥ÿßÿ≥Ÿäÿ© ÿ£Ÿà ŸÜŸÜÿ¥ÿ¶Ÿáÿß ŸÑŸà ŸÖÿ¥ ŸÖŸàÿ¨ŸàÿØÿ©
//   let incomeSummary = await this.accountRepository.findOne({
//     where: { accountCode: '9999' }, // ŸÉŸàÿØ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÑŸÄ income_summary
//   });
//   if (!incomeSummary) {
//     incomeSummary = this.accountRepository.create({
//       accountCode: '9999',
//       name: 'income_summary',
//       type: 'Equity',
//     });
//     await this.accountRepository.save(incomeSummary);
//   }

//   let retainedEarnings = await this.accountRepository.findOne({
//     where: { accountCode: '9998' }, // ŸÉŸàÿØ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÑŸÄ retained_earnings
//   });
//   if (!retainedEarnings) {
//     retainedEarnings = this.accountRepository.create({
//       accountCode: '9998',
//       name: 'retained_earnings',
//       type: 'Equity',
//     });
//     await this.accountRepository.save(retainedEarnings);
//   }

//   // ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
//   const closingEntry = this.journalEntryRepository.create({
//     date: end,
//     description: `Closing entry for year ${year}`,
//     entries: [
//       this.journalEntryLineRepository.create({
//         account: incomeSummary,
//         debit: totalRevenue,
//         credit: 0,
//       }),
//       this.journalEntryLineRepository.create({
//         account: incomeSummary,
//         debit: 0,
//         credit: totalExpense,
//       }),
//       income >= 0
//         ? this.journalEntryLineRepository.create({
//             account: retainedEarnings,
//             debit: 0,
//             credit: income,
//           })
//         : this.journalEntryLineRepository.create({
//             account: retainedEarnings,
//             debit: -income,
//             credit: 0,
//           }),
//     ],
//   });

//   await this.journalEntryRepository.save(closingEntry);

//   fiscalYear.isClosed = true;
//   fiscalYear.closedAt = new Date();
//   await this.fiscalYearRepo.save(fiscalYear);

//   return { message: 'Year closed successfully', year, income };
// }


// fiscal-year.service.ts

// async closeYear(year: number) {
//   // 1) ÿ¨Ÿäÿ® ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ©
//   const fiscalYear = await this.fiscalYearRepository.findOne({
//     where: { year: year },
//     relations: ['journalEntries', 'journalEntries.entries', 'journalEntries.entries.account'],
//   });

//   if (!fiscalYear) {
//     throw new Error('Fiscal year not found');
//   }
//   if (fiscalYear.isClosed) {
//     throw new Error('Fiscal year is already closed');
//   }

//   // 2) ÿ¨Ÿäÿ® ŸÉŸÑ ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ŸÖŸÜ ÿ¥ÿ¨ÿ±ÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™
//   const accounts = await this.accountRepository.find();

//   // 3) ŸÅŸÑÿ™ÿ±ÿ© ÿßŸÑÿ•Ÿäÿ±ÿßÿØÿßÿ™ ŸàÿßŸÑŸÖÿµÿ±ŸàŸÅÿßÿ™
//   const revenueAccounts = accounts.filter((a) => a.type === AccountType.Revenue);
//   const expenseAccounts = accounts.filter((a) => a.type === AccountType.Expense);

//   // 4) ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä
//   let totalRevenue = 0;
//   let totalExpense = 0;

//   for (const entry of fiscalYear.journalEntries) {
//     for (const line of entry.entries) {
//       if (line.account.type === AccountType.Revenue) {
//         totalRevenue += Number(line.credit) - Number(line.debit);
//       }
//       if (line.account.type === AccountType.Expense) {
//         totalExpense += Number(line.debit) - Number(line.credit);
//       }
//     }
//   }

//   const netIncome = totalRevenue - totalExpense;

//   // 5) ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® Income Summary ŸÑŸà ŸÖÿ¥ ŸÖŸàÿ¨ŸàÿØ
//   let incomeSummary = await this.accountRepository.findOne({
//     where: { name: 'Income Summary' },
//   });

//   if (!incomeSummary) {
//     incomeSummary = this.accountRepository.create({
//       name: 'Income Summary',
//       type: AccountType.Equity,
//       accountCode: '3999',
//       isMain: false,
//       isSub: true,
//     });
//     await this.accountRepository.save(incomeSummary);
//   }

//   // 6) ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® Retained Earnings ŸÑŸà ŸÖÿ¥ ŸÖŸàÿ¨ŸàÿØ
//   let retainedEarnings = await this.accountRepository.findOne({
//     where: { name: 'Retained Earnings' },
//   });

//   if (!retainedEarnings) {
//     retainedEarnings = this.accountRepository.create({
//       name: 'Retained Earnings',
//       type: AccountType.Equity,
//       accountCode: '3100',
//       isMain: false,
//       isSub: true,
//     });
//     await this.accountRepository.save(retainedEarnings);
//   }

//   // 7) ÿ•ŸÜÿ¥ÿßÿ° ŸÇŸäÿØ ÿ•ŸÇŸÅÿßŸÑ ÿßŸÑÿ≥ŸÜÿ©
//   const closingEntry = this.journalEntryRepository.create({
//     description: `Closing entries for Fiscal Year ${fiscalYear.year}`,
//     date: new Date(),
//     fiscalYear,
//     entries: [],
//   });

//   // ÿ•ŸÇŸÅÿßŸÑ ÿßŸÑÿ•Ÿäÿ±ÿßÿØÿßÿ™: ÿ™ÿ≠ŸàŸäŸÑŸáÿß ÿ•ŸÑŸâ Income Summary
//   for (const acc of revenueAccounts) {
//     closingEntry.entries.push(
//       this.journalEntryLineRepository.create({
//         account: acc,
//         debit: await this.getAccountBalance(acc.id),
//         credit: 0,
//       }),
//     );
//   }

//   // ÿ•ŸÇŸÅÿßŸÑ ÿßŸÑŸÖÿµÿ±ŸàŸÅÿßÿ™: ÿ™ÿ≠ŸàŸäŸÑŸáÿß ÿ•ŸÑŸâ Income Summary
//   for (const acc of expenseAccounts) {
//     closingEntry.entries.push(
//       this.journalEntryLineRepository.create({
//         account: acc,
//         debit: 0,
//         credit: await this.getAccountBalance(acc.id),
//       }),
//     );
//   }

//   // ŸÇŸäÿØ ÿ™ÿ≠ŸàŸäŸÑ ÿµÿßŸÅŸä ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© ÿ•ŸÑŸâ Retained Earnings
//   if (netIncome > 0) {
//     // ÿ±ÿ®ÿ≠
//     closingEntry.entries.push(
//       this.journalEntryLineRepository.create({
//         account: incomeSummary,
//         debit: netIncome,
//         credit: 0,
//       }),
//       this.journalEntryLineRepository.create({
//         account: retainedEarnings,
//         debit: 0,
//         credit: netIncome,
//       }),
//     );
//   } else if (netIncome < 0) {
//     // ÿÆÿ≥ÿßÿ±ÿ©
//     closingEntry.entries.push(
//       this.journalEntryLineRepository.create({
//         account: retainedEarnings,
//         debit: Math.abs(netIncome),
//         credit: 0,
//       }),
//       this.journalEntryLineRepository.create({
//         account: incomeSummary,
//         debit: 0,
//         credit: Math.abs(netIncome),
//       }),
//     );
//   }

//   await this.journalEntryRepository.save(closingEntry);

//   // 8) ŸÇŸÅŸÑ ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
//   fiscalYear.isClosed = true;
//   await this.fiscalYearRepository.save(fiscalYear);

//   // 9) ŸÅÿ™ÿ≠ ÿ≥ŸÜÿ© ÿ¨ÿØŸäÿØÿ©
//   const newFiscalYear = this.fiscalYearRepository.create({
//     year: fiscalYear.year + 1,
//     isClosed: false,
//   });
//   await this.fiscalYearRepository.save(newFiscalYear);

//   return {
//     message: `Fiscal year ${fiscalYear.year} closed successfully. Net income: ${netIncome}`,
//     newFiscalYear,
//   };
// }


// async closeYear(year: number, userId: string): Promise<void> {
//   const fiscalYear = await this.fiscalYearRepository.findOne({
//     where: { year },
//     relations: ['journalEntries', 'journalEntries.entries'],
//   });

//   if (!fiscalYear) {
//     throw new NotFoundException(`Fiscal year ${year} not found`);
//   }

//   if (fiscalYear.isClosed) {
//     throw new BadRequestException(`Fiscal year ${year} is already closed`);
//   }

//   // 1. Ÿáÿßÿ™ ŸÉŸÑ ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™
//   const accounts = await this.accountRepository.find();

//   // 2. Ÿáÿßÿ™ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ (ÿ¢ÿÆÿ± ŸäŸàŸÖ ŸÅŸä ÿßŸÑÿ≥ŸÜÿ©)
//   const closingDate = new Date(`${year}-12-31`);

//   // 3. ÿßÿ≠ÿ≥ÿ® sequenceNumber ŸÑŸÑÿ¥Ÿáÿ± (ÿØŸäÿ≥ŸÖÿ®ÿ± ŸáŸÜÿß)
//   const month = closingDate.getMonth() + 1; // (1-12)
//   const existingEntries = await this.journalEntryRepository
//     .createQueryBuilder('entry')
//     .where('EXTRACT(MONTH FROM entry.date) = :month', { month })
//     .andWhere('EXTRACT(YEAR FROM entry.date) = :year', { year })
//     .orderBy('entry.sequenceNumber', 'DESC')
//     .getOne();

//   const nextSequenceNumber = existingEntries ? existingEntries.sequenceNumber + 1 : 1;

//   // 4. ÿ£ŸÜÿ¥ÿ¶ ŸÇŸäÿØ ÿ•ŸÇŸÅÿßŸÑ
//   const closingEntry = this.journalEntryRepository.create({
//     date: closingDate,
//     description: `Closing entries for Fiscal Year ${year}`,
//     sequenceNumber: nextSequenceNumber, // üëà ŸáŸÜÿß ÿßŸÑÿ±ŸÇŸÖ ÿØÿßÿÆŸÑ ÿßŸÑÿ¥Ÿáÿ±
//     fiscalYear,
//   createdBy: { id: userId } as unknown as DeepPartial<UserEntity>,
//   });

//   closingEntry.entries = [];

//   // 5. ŸÇŸÅŸÑ ŸÉŸÑ ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ© (ÿ•Ÿäÿ±ÿßÿØÿßÿ™ ŸàŸÖÿµÿ±ŸàŸÅÿßÿ™)
//   for (const acc of accounts) {
//     if (acc.type === AccountType.Revenue || acc.type === AccountType.Expense) {
//       const balance = await this.getAccountBalance(acc.id);

//       if (balance !== 0) {
//         closingEntry.entries.push(
//           this.journalEntryLineRepository.create({
//             account: acc,
//             debit: balance > 0 ? balance : 0,
//             credit: balance < 0 ? -balance : 0,
//           }),
//         );
//       }
//     }
//   }

//   // 6. ÿßÿ≠ŸÅÿ∏ ÿßŸÑŸÇŸäÿØ
//   await this.journalEntryRepository.save(closingEntry);

//   // 7. ÿπŸÑŸÖ ÿßŸÑÿ≥ŸÜÿ© ÿ•ŸÜŸáÿß ÿßÿ™ŸÇŸÅŸÑÿ™
//   fiscalYear.isClosed = true;
//   await this.fiscalYearRepository.save(fiscalYear);
// }


// async closeYear(year: number, userId: string) {
//   // 1. ÿ™ÿ£ŸÉÿØ ÿ•ŸÜ ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ© ŸÖŸàÿ¨ŸàÿØÿ©
//   const fiscalYear = await this.fiscalYearRepository.findOne({
//     where: { year },
//   });
//   if (!fiscalYear) {
//     throw new NotFoundException(`Fiscal year ${year} not found`);
//   }

//   // 2. ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ = ÿ¢ÿÆÿ± ŸäŸàŸÖ ŸÅŸä ÿßŸÑÿ≥ŸÜÿ©
//   const closingDate = new Date(year, 11, 31);

//   // 3. Ÿáÿßÿ™ ÿ¢ÿÆÿ± sequenceNumber ŸÑŸÑÿ¥Ÿáÿ± (ÿØÿßÿÆŸÑ ÿØŸäÿ≥ŸÖÿ®ÿ± ŸáŸÜÿß)
//   const lastEntryForMonth = await this.journalEntryRepository.findOne({
//     where: {
//       fiscalYear: { id: fiscalYear.id },
//       date: Between(new Date(year, 11, 1), closingDate),
//     },
//     order: { sequenceNumber: 'DESC' },
//   });

//   const nextSequenceNumber = lastEntryForMonth
//     ? lastEntryForMonth.sequenceNumber + 1
//     : 1;

//   // 4. ÿßŸÑÿ¥Ÿáÿ± (0-based ‚Üí +1)
//   const month = closingDate.getMonth() + 1;

//   // 5. ÿ™ŸàŸÑŸäÿØ ÿßŸÑŸÉŸàÿØ: year-month-sequence
//   const code = `${year}-${month}-${nextSequenceNumber}`;

//   // 6. ÿ•ŸÜÿ¥ÿßÿ° ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
//   const closingEntry = this.journalEntryRepository.create({
//     date: closingDate,
//     description: `Closing entries for Fiscal Year ${year}`,
//     sequenceNumber: nextSequenceNumber,
//     code,
//     fiscalYear,
//     createdBy: { id: userId } as any, // üëà ÿπÿ¥ÿßŸÜ Ÿäÿ≠ŸÑ ŸÖÿ¥ŸÉŸÑÿ© ÿßŸÑŸÄ type
//   });

//   // 7. ÿßÿ≠ŸÅÿ∏ ÿßŸÑŸÇŸäÿØ
//   await this.journalEntryRepository.save(closingEntry);

//   // 8. ÿπÿØŸÑ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ© ÿ•ŸÑŸâ ŸÖŸÇŸÅŸàŸÑÿ©
//   fiscalYear.isClosed = true;
//   fiscalYear.closedAt = new Date();
//   fiscalYear.closedBy = userId;
//   await this.fiscalYearRepository.save(fiscalYear);

//   return closingEntry;
// }


// async closeYear(year: number, userId: string): Promise<void> {
//   const fiscalYear = await this.fiscalYearRepository.findOne({
//     where: { year },
//     relations: ['journalEntries', 'journalEntries.entries'],
//   });

//   if (!fiscalYear) {
//     throw new NotFoundException(`Fiscal year ${year} not found`);
//   }
//   if (fiscalYear.isClosed) {
//     throw new BadRequestException(`Fiscal year ${year} is already closed`);
//   }

//   // 1. ÿ≠ÿ≥ÿßÿ® ÿ£ÿ±ÿµÿØÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©
//   const tempAccounts = ['Revenue', 'Expense'];
//   const accountBalances = new Map<number, number>();

// for (const entry of fiscalYear.journalEntries) {
//   for (const line of entry.entries) {
//     if (tempAccounts.includes(line.account.type)) {
//       const prev = accountBalances.get(line.account.id) || 0;
//       accountBalances.set(line.account.id, prev + line.debit - line.credit);
//     }
//   }
// }

//   // 2. ÿ¨Ÿáÿ≤ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
//   const closingDate = new Date(year, 11, 31); // ÿ¢ÿÆÿ± ŸäŸàŸÖ ŸÅŸä ÿßŸÑÿ≥ŸÜÿ©

//   // 3. Ÿáÿßÿ™ ÿ¢ÿÆÿ± sequenceNumber ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑÿ¥Ÿáÿ±
//   const lastEntry = await this.journalEntryRepository.findOne({
//     where: {
//       date: Between(
//         new Date(closingDate.getFullYear(), closingDate.getMonth(), 1),
//         new Date(closingDate.getFullYear(), closingDate.getMonth() + 1, 0),
//       ),
//     },
//     order: { sequenceNumber: 'DESC' },
//   });

//   const nextSequenceNumber = lastEntry ? lastEntry.sequenceNumber + 1 : 1;

//   // 4. ÿ£ŸÜÿ¥ÿ¶ ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
//   const closingEntry = this.journalEntryRepository.create({
//     date: closingDate,
//     description: `Closing entries for Fiscal Year ${year}`,
//     sequenceNumber: nextSequenceNumber,
//     code: `${closingDate.getFullYear()}-${closingDate.getMonth() + 1}-${nextSequenceNumber}`,
//     fiscalYear,
//     createdBy: { id: userId } as any, // üëà relation ŸÖÿπ UserEntity
//   });

//   // 5. ÿ£ÿ∂ŸÅ ÿßŸÑŸÇŸäŸàÿØ (lines)
//   closingEntry.entries = [];
//   for (const [accountId, balance] of accountBalances) {
//     if (balance !== 0) {
//       closingEntry.entries.push(
//         this.journalEntryLineRepository.create({
//           account: { id: accountId } as any,
//           debit: balance < 0 ? -balance : 0,
//           credit: balance > 0 ? balance : 0,
//         }),
//       );
//     }
//   }

//   await this.journalEntryRepository.save(closingEntry);

//   // 6. ÿ≠ÿØÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ©
//   fiscalYear.isClosed = true;
//   fiscalYear.closedAt = new Date();
//   fiscalYear.closedBy = { id: userId } as any; // üëà relation ŸÖÿπ UserEntity

//   await this.fiscalYearRepository.save(fiscalYear);
// }


// async closeYear(year: number, userId: string): Promise<void> {
//   const fiscalYear = await this.fiscalYearRepository.findOne({
//     where: { year },
//     relations: ['journalEntries', 'journalEntries.entries'],
//   });

//   if (!fiscalYear) {
//     throw new NotFoundException(`Fiscal year ${year} not found`);
//   }
//   if (fiscalYear.isClosed) {
//     throw new BadRequestException(`Fiscal year ${year} is already closed`);
//   }

//   // 1. ÿ≠ÿ≥ÿßÿ® ÿ£ÿ±ÿµÿØÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©
//   const tempAccounts = ['Revenue', 'Expense'];
//   const accountBalances = new Map<number, number>();

//   for (const entry of fiscalYear.journalEntries) {
//     for (const line of entry.entries) {
//       if (tempAccounts.includes(line.account.type)) {
//         const prev = accountBalances.get(line.account.id) || 0;
//         accountBalances.set(line.account.id, prev + line.debit - line.credit);
//       }
//     }
//   }

//   // 2. ÿ¨Ÿáÿ≤ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
//   const closingDate = new Date(year, 11, 31); // ÿ¢ÿÆÿ± ŸäŸàŸÖ ŸÅŸä ÿßŸÑÿ≥ŸÜÿ©

//   // 3. Ÿáÿßÿ™ ÿ¢ÿÆÿ± sequenceNumber ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑÿ¥Ÿáÿ±
//   const lastEntry = await this.journalEntryRepository.findOne({
//     where: {
//       date: Between(
//         new Date(closingDate.getFullYear(), closingDate.getMonth(), 1),
//         new Date(closingDate.getFullYear(), closingDate.getMonth() + 1, 0),
//       ),
//     },
//     order: { sequenceNumber: 'DESC' },
//   });

//   const nextSequenceNumber = lastEntry ? lastEntry.sequenceNumber + 1 : 1;

//   // 4. ÿ£ŸÜÿ¥ÿ¶ ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
//   const closingEntry = this.journalEntryRepository.create({
//     date: closingDate,
//     description: `Closing entries for Fiscal Year ${year}`,
//     sequenceNumber: nextSequenceNumber,
//     code: `${closingDate.getFullYear()}-${closingDate.getMonth() + 1}-${nextSequenceNumber}`,
//     fiscalYear,
//     createdBy: { id: userId } as any,
//     isClosing: true, // ‚úÖ ÿπŸÑÿßŸÖÿ© ÿ•ŸÜŸá ŸÇŸäÿØ ÿ•ŸÇŸÅÿßŸÑ
//   });

//   // 5. ÿ£ÿ∂ŸÅ ÿßŸÑŸÇŸäŸàÿØ (lines)
//   closingEntry.entries = [];
//   for (const [accountId, balance] of accountBalances) {
//     if (balance !== 0) {
//       closingEntry.entries.push(
//         this.journalEntryLineRepository.create({
//           account: { id: accountId } as any,
//           debit: balance < 0 ? -balance : 0,
//           credit: balance > 0 ? balance : 0,
//         }),
//       );
//     }
//   }

//   await this.journalEntryRepository.save(closingEntry);

//   // 6. ÿ≠ÿØÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ©
//   fiscalYear.isClosed = true;
//   fiscalYear.closedAt = new Date();
//   fiscalYear.closedBy = { id: userId } as any; // üëà ÿØŸÑŸàŸÇÿ™Ÿä relation ŸÖÿπ UserEntity

//   await this.fiscalYearRepository.save(fiscalYear);
// }


// async closeYear(year: number, userId: string): Promise<void> {
//   const fiscalYear = await this.fiscalYearRepository.findOne({
//     where: { year },
//     relations: ['journalEntries', 'journalEntries.entries'],
//   });

//   if (!fiscalYear) {
//     throw new NotFoundException(`Fiscal year ${year} not found`);
//   }
//   if (fiscalYear.isClosed) {
//     throw new BadRequestException(`Fiscal year ${year} is already closed`);
//   }

//   // 1Ô∏è‚É£ ÿ≠ÿ≥ÿßÿ® ÿ£ÿ±ÿµÿØÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©
//   const tempAccounts = ['Revenue', 'Expense'];
//   const accountBalances = new Map<number, number>();

//   for (const entry of fiscalYear.journalEntries) {
//     for (const line of entry.entries) {
//       if (tempAccounts.includes(line.account.type)) {
//         const prev = accountBalances.get(line.account.id) || 0;
//         accountBalances.set(
//           line.account.id,
//           prev + Number(line.debit) - Number(line.credit),
//         );
//       }
//     }
//   }

//   // 2Ô∏è‚É£ ÿ¨Ÿáÿ≤ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
//   const closingDate = new Date(year, 11, 31); // ÿ¢ÿÆÿ± ŸäŸàŸÖ ŸÅŸä ÿßŸÑÿ≥ŸÜÿ©

//   // 3Ô∏è‚É£ Ÿáÿßÿ™ ÿ¢ÿÆÿ± sequenceNumber ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑÿ¥Ÿáÿ±
//   const lastEntry = await this.journalEntryRepository.findOne({
//     where: {
//       date: Between(
//         new Date(closingDate.getFullYear(), closingDate.getMonth(), 1),
//         new Date(closingDate.getFullYear(), closingDate.getMonth() + 1, 0),
//       ),
//     },
//     order: { sequenceNumber: 'DESC' },
//   });

//   const nextSequenceNumber = lastEntry ? lastEntry.sequenceNumber + 1 : 1;

//   // 4Ô∏è‚É£ ÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿ≠ÿ≥ÿßÿ® Income Summary
//   const incomeSummary = await this.accountRepository.findOne({
//     where: { name: 'Income Summary' },
//   });
//   if (!incomeSummary) {
//     throw new NotFoundException(
//       'Income Summary account not found, please create it first',
//     );
//   }

//   // 5Ô∏è‚É£ ÿ£ŸÜÿ¥ÿ¶ ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
//   const closingEntry = this.journalEntryRepository.create({
//     date: closingDate,
//     description: `Closing entries for Fiscal Year ${year}`,
//     sequenceNumber: nextSequenceNumber,
//     code: `${closingDate.getFullYear()}-${closingDate.getMonth() + 1}-${nextSequenceNumber}`,
//     fiscalYear,
//     createdBy: { id: userId } as any, // relation ŸÖÿπ UserEntity
//     isClosing: true, // ‚úÖ ÿπŸÑŸÖŸá ÿ•ŸÜŸá ŸÇŸäÿØ ÿ•ŸÇŸÅÿßŸÑ
//   });

//   closingEntry.entries = [];

//   // 6Ô∏è‚É£ ÿ£ÿ∂ŸÅ ŸÇŸäŸàÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ ŸÑŸÉŸÑ ÿ≠ÿ≥ÿßÿ® ŸÖÿ§ŸÇÿ™
//   let totalBalance = 0;
//   for (const [accountId, balance] of accountBalances) {
//     if (balance !== 0) {
//       totalBalance += balance;
//       closingEntry.entries.push(
//         this.journalEntryLineRepository.create({
//           account: { id: accountId } as any,
//           debit: balance < 0 ? -balance : 0,
//           credit: balance > 0 ? balance : 0,
//         }),
//       );
//     }
//   }

//   // 7Ô∏è‚É£ ÿ£ÿ∂ŸÅ ÿßŸÑÿ∑ÿ±ŸÅ ÿßŸÑŸÖŸÇÿßÿ®ŸÑ (Income Summary)
//   if (totalBalance !== 0) {
//     closingEntry.entries.push(
//       this.journalEntryLineRepository.create({
//         account: { id: incomeSummary.id } as any,
//         debit: totalBalance > 0 ? totalBalance : 0,
//         credit: totalBalance < 0 ? -totalBalance : 0,
//       }),
//     );
//   }

//   await this.journalEntryRepository.save(closingEntry);

//   // 8Ô∏è‚É£ ÿ≠ÿØÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ©
//   fiscalYear.isClosed = true;
//   fiscalYear.closedAt = new Date();
//   fiscalYear.closedBy = { id: userId } as any;

//   await this.fiscalYearRepository.save(fiscalYear);
// }

// async closeYear(fiscalYearId: number, userId: number) {
//   const fiscalYear = await this.fiscalYearRepository.findOne({
//     where: { year: fiscalYearId },
//     relations: ["journalEntries", "journalEntries.entries", "journalEntries.entries.account"],
//   });

//   if (!fiscalYear) {
//     throw new NotFoundException(`Fiscal year ${fiscalYearId} not found`);
//   }

//   if (fiscalYear.isClosed) {
//     throw new BadRequestException(`Fiscal year ${fiscalYearId} is already closed`);
//   }

//   const user = await this.userRepositry.findOneBy({ id: userId });
//   if (!user) throw new NotFoundException(`User ${userId} not found`);

//   const incomeSummary = await this.accountRepository.findOne({
//     where: { name: "Income Summary" },
//   });

//   if (!incomeSummary) {
//     throw new NotFoundException("Income Summary account not found");
//   }

//   // ÿßÿ¨ŸÖÿπ ÿ£ÿ±ÿµÿØÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©
//   const accountBalances = new Map<number, number>();
//   const tempAccounts: AccountType[] = [AccountType.Revenue, AccountType.Expense];

//   for (const entry of fiscalYear.journalEntries) {
//     for (const line of entry.entries) {
//       if (tempAccounts.includes(line.account.type)) {
//         const prev = accountBalances.get(line.account.id) || 0;
//         accountBalances.set(line.account.id, prev + Number(line.debit) - Number(line.credit));
//       }
//     }
//   }

//   // ÿßÿπŸÖŸÑ ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
//   const closingEntry = this.journalEntryRepository.create({
//   date: new Date(fiscalYear.year, 11, 31), 
//     description: `Closing entries for Fiscal Year ${fiscalYear.year}`,
//     sequenceNumber: 1,
//     code: `${fiscalYear.year}-12-1`,
//     isClosing: true,
//     createdBy: user,
//     fiscalYear,
//     entries: [],
//   });

//   const lines: JournalEntryLineEntity[] = [];

// // 2) ŸÑÿ®ÿ≥ÿßÿ∑ÿ© ŸÜŸÇÿ±ÿ£ ÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿµÿØÿ± ÿßÿ∞ÿß ÿßÿ≠ÿ™ÿ¨ÿ™ ÿ®ŸäÿßŸÜÿßÿ™ ÿßÿ∂ÿßŸÅŸäÿ©
// for (const [accountId, balanceValue] of accountBalances) {
//   const balance = Number(balanceValue);
//   if (!balance) continue; // skip zero

//   // optional: ÿ¨ŸÑÿ® ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÉÿßŸÖŸÑ ŸÖŸÜ DB (ŸÑŸà ŸÖÿ≠ÿ™ÿßÿ¨ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßÿ∂ÿßŸÅŸäÿ©)
//   const account = await this.accountRepository.findOne({ where: { id: accountId } });
//   if (!account) {
//     // ŸÖŸÖŸÉŸÜ ÿ™ÿ±ŸÖŸä ÿÆÿ∑ÿ£ ÿßŸà ÿ™ŸÉŸÖŸÑ ÿ≠ÿ≥ÿ® ŸÖŸÜÿ∑ŸÇŸÉ
//     continue;
//   }

//   if (balance > 0) {
//     // ÿ≠ÿ≥ÿßÿ® ŸÑŸá ÿ±ÿµŸäÿØ ÿØÿßÿ¶ŸÜ -> ŸÜÿπŸÖŸÑ ÿ≥ÿ∑ÿ± ÿØÿßÿ¶ŸÜ ŸÑŸÑÿ≠ÿ≥ÿßÿ® Ÿàÿ≥ÿ∑ÿ± ŸÖÿØŸäŸÜ ŸÑŸÄ incomeSummary
//     lines.push(
//       this.journalEntryLineRepository.create({
//         account: { id: account.id } as any,
//         debit: 0,
//         credit: balance,
//         journalEntry: closingEntry,
//       }),
//     );

//     lines.push(
//       this.journalEntryLineRepository.create({
//         account: { id: incomeSummary.id } as any,
//         debit: balance,
//         credit: 0,
//         journalEntry: closingEntry,
//       }),
//     );
//   } else {
//     const abs = Math.abs(balance);
//     // ÿ±ÿµŸäÿØ ŸÖÿØŸäŸÜ -> ÿ≥ÿ∑ÿ± ŸÖÿØŸäŸÜ ŸÑŸÑÿ≠ÿ≥ÿßÿ® Ÿà ÿ≥ÿ∑ÿ± ÿØÿßÿ¶ŸÜ ŸÑŸÄ incomeSummary
//     lines.push(
//       this.journalEntryLineRepository.create({
//         account: { id: account.id } as any,
//         debit: abs,
//         credit: 0,
//         journalEntry: closingEntry,
//       }),
//     );

//     lines.push(
//       this.journalEntryLineRepository.create({
//         account: { id: incomeSummary.id } as any,
//         debit: 0,
//         credit: abs,
//         journalEntry: closingEntry,
//       }),
//     );
//   }
// }

// // ÿßÿ≥ŸÜÿØ ÿßŸÑÿ£ÿ≥ÿ∑ÿ± ŸÑŸÑŸÇŸäÿØ ŸÇÿ®ŸÑ ÿßŸÑÿ≠ŸÅÿ∏
// closingEntry.entries = lines;

// // ÿßÿ≠ŸÅÿ∏ ÿßŸÑŸÇŸäÿØ (ÿ≥ŸàŸÅ Ÿäÿ≠ŸÅÿ∏ ÿßŸÑÿ£ÿ≥ÿ∑ÿ± ŸÑÿ£ŸÜ relation cascade: true ÿπŸÜÿØŸÉ)
// await this.journalEntryRepository.save(closingEntry);

  
//   // ÿßÿ±ÿ®ÿ∑ ÿßŸÑŸÄ lines ÿ®ÿßŸÑŸÇŸäÿØ
//   // const lines = [];
//   // for (const [accountId, balance] of accountBalances.entries()) {
//   //   const account = await this.accountRepository.findOneBy({ id: accountId });
//   //   if (!account) continue;

//   //   if (balance > 0) {
//   //     lines.push(
//   //       this.journalEntryLineRepository.create({
//   //         account,
//   //         debit: 0,
//   //         credit: balance,
//   //         journalEntry: closingEntry,
//   //       }),
//   //     );
//   //     lines.push(
//   //       this.journalEntryLineRepository.create({
//   //         account: incomeSummary,
//   //         debit: balance,
//   //         credit: 0,
//   //         journalEntry: closingEntry,
//   //       }),
//   //     );
//   //   } else if (balance < 0) {
//   //     lines.push(
//   //       this.journalEntryLineRepository.create({
//   //         account,
//   //         debit: -balance,
//   //         credit: 0,
//   //         journalEntry: closingEntry,
//   //       }),
//   //     );
//   //     lines.push(
//   //       this.journalEntryLineRepository.create({
//   //         account: incomeSummary,
//   //         debit: 0,
//   //         credit: -balance,
//   //         journalEntry: closingEntry,
//   //       }),
//   //     );
//   //   }
//   // }

//   // closingEntry.entries = lines;

//   // await this.journalEntryRepository.save(closingEntry);

//   // fiscalYear.isClosed = true;
//   // fiscalYear.closedBy = user;
//   // await this.fiscalYearRepository.save(fiscalYear);

//   return closingEntry;
// }



// async closeYear(fiscalYearId: number, userId: number) {
//   const fiscalYear = await this.fiscalYearRepository.findOne({
//     where: { year: fiscalYearId },
//     relations: [
//       "journalEntries",
//       "journalEntries.entries",
//       "journalEntries.entries.account",
//     ],
//   });

//   if (!fiscalYear) {
//     throw new NotFoundException(`Fiscal year ${fiscalYearId} not found`);
//   }

//   if (fiscalYear.isClosed) {
//     throw new BadRequestException(`Fiscal year ${fiscalYearId} is already closed`);
//   }

//   const user = await this.userRepositry.findOneBy({ id: userId });
//   if (!user) throw new NotFoundException(`User ${userId} not found`);

//   const incomeSummary = await this.accountRepository.findOne({
//     where: { name: "Income Summary" },
//   });
//   if (!incomeSummary) {
//     throw new NotFoundException("Income Summary account not found");
//   }

//   // üü¢ ÿ≠ÿ≥ÿßÿ® ÿ£ÿ±ÿµÿØÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©
//   const accountBalances = new Map<number, number>();
//   const tempAccounts: AccountType[] = [AccountType.Revenue, AccountType.Expense];

//   for (const entry of fiscalYear.journalEntries) {
//     for (const line of entry.entries) {
//       if (tempAccounts.includes(line.account.type)) {
//         const prev = accountBalances.get(line.account.id) || 0;
//         accountBalances.set(
//           line.account.id,
//           prev + Number(line.debit) - Number(line.credit),
//         );
//       }
//     }
//   }

//   // üü¢ ÿßÿ≠ÿ≥ÿ® sequenceNumber ÿßŸÑÿ£ÿÆŸäÿ± ŸÅŸä ÿØŸäÿ≥ŸÖÿ®ÿ±
//   const startOfDecember = new Date(fiscalYear.year, 11, 1);
//   const endOfDecember = new Date(fiscalYear.year, 11, 31);

//   const lastEntry = await this.journalEntryRepository
//     .createQueryBuilder("entry")
//     .where("entry.date BETWEEN :start AND :end", {
//       start: startOfDecember,
//       end: endOfDecember,
//     })
//     .orderBy("entry.sequenceNumber", "DESC")
//     .getOne();

//   const nextSequenceNumber = lastEntry ? lastEntry.sequenceNumber + 1 : 1;

//   // üü¢ ÿ¨Ÿáÿ≤ ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
//   const closingEntry = this.journalEntryRepository.create({
//     date: new Date(fiscalYear.year, 11, 31), // 31 ÿØŸäÿ≥ŸÖÿ®ÿ±
//     description: `Closing entries for Fiscal Year ${fiscalYear.year}`,
//     sequenceNumber: nextSequenceNumber,
//     code: `${fiscalYear.year}-12-${nextSequenceNumber}`,
//     isClosing: true,
//     createdBy: user,
//     fiscalYear,
//     entries: [],
//   });

//   const lines: JournalEntryLineEntity[] = [];

//   // üü¢ ÿ£ŸÜÿ¥ÿ¶ ÿßŸÑÿ£ÿ≥ÿ∑ÿ±
//   for (const [accountId, balanceValue] of accountBalances) {
//     const balance = Number(balanceValue);
//     if (!balance) continue;

//     const account = await this.accountRepository.findOne({
//       where: { id: accountId },
//     });
//     if (!account) continue;

//     if (balance > 0) {
//       // ÿ±ÿµŸäÿØ ÿØÿßÿ¶ŸÜ
//       lines.push({
//         account,
//         debit: 0,
//         credit: balance,
//       } as JournalEntryLineEntity);

//       lines.push({
//         account: incomeSummary,
//         debit: balance,
//         credit: 0,
//       } as JournalEntryLineEntity);
//     } else {
//       const abs = Math.abs(balance);
//       // ÿ±ÿµŸäÿØ ŸÖÿØŸäŸÜ
//       lines.push({
//         account,
//         debit: abs,
//         credit: 0,
//       } as JournalEntryLineEntity);

//       lines.push({
//         account: incomeSummary,
//         debit: 0,
//         credit: abs,
//       } as JournalEntryLineEntity);
//     }
//   }

//   // üü¢ ÿßÿ±ÿ®ÿ∑ ÿßŸÑÿ£ÿ≥ÿ∑ÿ± ÿ®ÿßŸÑŸÇŸäÿØ
//   closingEntry.entries = lines;

//   // üü¢ ÿßÿ≠ŸÅÿ∏ ÿßŸÑŸÇŸäÿØ ŸàÿßŸÑÿ£ÿ≥ÿ∑ÿ± (Cascade)
//   await this.journalEntryRepository.save(closingEntry);

//   // üü¢ ÿ≠ÿØÿ´ ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ©
//   fiscalYear.isClosed = true;
//   fiscalYear.closedBy = user;
//   await this.fiscalYearRepository.save(fiscalYear);

//   return closingEntry;
// }



// method inside FiscalYearService
// async closeYear(year: number, userId: number | string) {
//   return await this.dataSource.transaction(async (manager) => {
//     // 1) ÿ¨ŸÑÿ® ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ©
//     const fiscalYearRepo = manager.getRepository(FiscalYearEntity);
//     const fiscalYear = await fiscalYearRepo.findOne({ where: { year } });
//     if (!fiscalYear) throw new NotFoundException(`Fiscal year ${year} not found`);
//     if (fiscalYear.isClosed) throw new BadRequestException(`Fiscal year ${year} is already closed`);

//     // 2) ÿ™Ÿàÿßÿ±ŸäÿÆ ÿßŸÑÿ≥ŸÜÿ©
//     const start = new Date(year, 0, 1);
//     const end = new Date(year, 11, 31);

//     // 3) ÿßÿ¨ŸÖÿπ ÿ£ÿ±ÿµÿØÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ© (Revenue, Expense) ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿπŸÑŸâ journal_entry_lines
//     const lineQB = manager.getRepository(JournalEntryLineEntity).createQueryBuilder('line')
//       .leftJoin('line.journalEntry', 'je')
//       .leftJoin('line.account', 'account')
//       .select('account.id', 'accountId')
//       .addSelect('account.type', 'accountType')
//       .addSelect('SUM(line.debit)::numeric', 'sumDebit')
//       .addSelect('SUM(line.credit)::numeric', 'sumCredit')
//       .where('je.date BETWEEN :start AND :end', { start, end })
//       .andWhere('account.type IN (:...types)', { types: [AccountType.Revenue, AccountType.Expense] })
//       .groupBy('account.id')
//       .addGroupBy('account.type');

//     const aggregated: Array<{ accountId: string; accountType: string; sumDebit: string; sumCredit: string; }> =
//       await lineQB.getRawMany();

//     // 4) ÿ™ÿ£ŸÉÿØ ÿ£Ÿà ÿßŸÜÿ¥ÿ¶ ÿ≠ÿ≥ÿßÿ®ÿßÿ™ Income Summary Ÿà Retained Earnings
//     const accountRepo = manager.getRepository(AccountEntity);

//     let incomeSummary = await accountRepo.findOne({
//       where: [{ name: 'Income Summary' }, { name: 'income_summary' }],
//     });

//     if (!incomeSummary) {
//       incomeSummary = accountRepo.create({
//         name: 'Income Summary',
//         type: AccountType.Equity,
//         accountCode: `9999.${year}`, // ŸÖÿ´ÿßŸÑ ŸÉŸàÿØ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
//         isMain: false,
//         isSub: true,
//       });
//       incomeSummary = await accountRepo.save(incomeSummary);
//     }

//     let retainedEarnings = await accountRepo.findOne({
//       where: [{ name: 'Retained Earnings' }, { name: 'retained_earnings' }],
//     });

//     if (!retainedEarnings) {
//       retainedEarnings = accountRepo.create({
//         name: 'Retained Earnings',
//         type: AccountType.Equity,
//         accountCode: `3000.${year}`, // ŸÖÿ´ÿßŸÑ ŸÉŸàÿØ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
//         isMain: false,
//         isSub: true,
//       });
//       retainedEarnings = await accountRepo.save(retainedEarnings);
//     }

//     // 5) ÿ¨Ÿáÿ≤ ÿ£ÿ≥ÿ∑ÿ± ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ ÿ≠ÿ≥ÿ® ŸÇŸàÿßÿπÿØ ÿßŸÑŸÖÿ≠ÿßÿ≥ÿ®ÿ©:
//     //    - ŸÜÿ∫ŸÑŸÇ ÿ≠ÿ≥ÿßÿ®ÿßÿ™ Revenue ÿ®ÿØŸäŸÜŸáÿß (debit) ŸàŸÜŸÇŸäŸÖ credit ÿπŸÑŸâ Income Summary
//     //    - ŸÜÿ∫ŸÑŸÇ ÿ≠ÿ≥ÿßÿ®ÿßÿ™ Expense ÿ®ÿØŸäŸÜŸáÿß ÿπŸÑŸâ Income Summary (debit) ŸàŸÜŸÇŸäŸÖ credit ÿπŸÑŸâ Expense
//     const linesToCreate: JournalEntryLineEntity[] = [];
//     let totalRevenue = 0;
//     let totalExpense = 0;

//     for (const row of aggregated) {
//       const accId = Number(row.accountId);
//       const sumDebit = Number(row.sumDebit || 0);
//       const sumCredit = Number(row.sumCredit || 0);
//       const accType = row.accountType as AccountType;

//       if (accType === AccountType.Revenue) {
//         const revBalance = sumCredit - sumDebit; // positive => net credit
//         if (revBalance > 0) {
//           totalRevenue += revBalance;
//           // debit the revenue account to zero it
//           linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
//             account: { id: accId } as any,
//             debit: revBalance,
//             credit: 0,
//           }));
//           // credit income summary
//           linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
//             account: { id: incomeSummary.id } as any,
//             debit: 0,
//             credit: revBalance,
//           }));
//         }
//       } else if (accType === AccountType.Expense) {
//         const expBalance = sumDebit - sumCredit; // positive => net debit
//         if (expBalance > 0) {
//           totalExpense += expBalance;
//           // debit income summary
//           linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
//             account: { id: incomeSummary.id } as any,
//             debit: expBalance,
//             credit: 0,
//           }));
//           // credit the expense account to zero it
//           linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
//             account: { id: accId } as any,
//             debit: 0,
//             credit: expBalance,
//           }));
//         }
//       }
//     }

//     // 6) ÿßŸÑÿ¢ŸÜ ŸÜÿ≠ÿ≥ÿ® ÿµÿßŸÅŸä ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© ŸàŸÜŸÜŸÇŸÑŸá ŸÑŸÄ Retained Earnings
//     const net = totalRevenue - totalExpense; // >0 => net income (credit to Income Summary)
//     if (net > 0) {
//       // incomeSummary currently has a credit (sum of credits we posted). To transfer to retained earnings:
//       // debit incomeSummary, credit retained earnings
//       linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
//         account: { id: incomeSummary.id } as any,
//         debit: net,
//         credit: 0,
//       }));
//       linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
//         account: { id: retainedEarnings.id } as any,
//         debit: 0,
//         credit: net,
//       }));
//     } else if (net < 0) {
//       const abs = Math.abs(net);
//       // net loss -> debit retained earnings, credit income summary
//       linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
//         account: { id: retainedEarnings.id } as any,
//         debit: abs,
//         credit: 0,
//       }));
//       linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
//         account: { id: incomeSummary.id } as any,
//         debit: 0,
//         credit: abs,
//       }));
//     }
//     // ÿ•ÿ∞ÿß net == 0 ŸÅŸÑÿß ŸÜŸÇŸÑ

//     // 7) ÿßÿ≠ÿ≥ÿ® next sequenceNumber ŸÑÿ¥Ÿáÿ± ÿØŸäÿ≥ŸÖÿ®ÿ±
//     const startDec = new Date(year, 11, 1);
//     const endDec = new Date(year, 11, 31);
//     const lastDecEntry = await manager.getRepository(JournalEntryEntity)
//       .createQueryBuilder('entry')
//       .where('entry.date BETWEEN :start AND :end', { start: startDec, end: endDec })
//       .orderBy('entry.sequenceNumber', 'DESC')
//       .getOne();

//     const nextSeq = lastDecEntry ? lastDecEntry.sequenceNumber + 1 : 1;

//     // 8) ÿ£ŸÜÿ¥ÿ¶ ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ ÿ®ŸÜŸÅÿ≥ ÿ£ÿ≥ŸÑŸàÿ® create() ÿπŸÜÿØŸÉ (entries ŸÖÿµŸÜŸàÿπÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© journalEntryLineRepository.create)
//     const journalRepo = manager.getRepository(JournalEntryEntity);
//     const closingEntry = journalRepo.create({
//       date: end, // 31 Dec
//       description: `Closing entries for Fiscal Year ${year}`,
//       sequenceNumber: nextSeq,
//       code: `${year}-${end.getMonth() + 1}-${nextSeq}`,
//       isClosing: true, // ŸÑŸà ÿ∂ŸÅÿ™ Ÿáÿ∞ÿß ÿßŸÑÿ≠ŸÇŸÑ ŸÅŸä ÿßŸÑŸÄ entity
//       createdBy: { id: userId } as any,
//       lastModifiedBy: { id: userId } as any,
//       entries: linesToCreate,
//     });

//     const savedClosing = await journalRepo.save(closingEntry);

//     // 9) ÿ≠ÿØŸëÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ© (isClosed, closedAt, closedBy)
//     fiscalYear.isClosed = true;
//     fiscalYear.closedAt = new Date();
//     // closedBy relation -> object with id
//     // ÿ•ÿ∞ÿß ÿπŸÜÿØŸÉ closedBy ŸÉŸÄ uuid/string ÿ®ÿØŸÑ relation ŸÅŸÖÿ±Ÿëÿ± id ŸÖÿ®ÿßÿ¥ÿ±ÿ©
//     (fiscalYear as any).closedBy = { id: userId } as any;

//     await fiscalYearRepo.save(fiscalYear);

//     // 10) ÿßÿ±ÿ¨ÿπ ÿßŸÑŸÇŸäÿØ ÿ®ÿπÿØ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿπŸÑÿßŸÇÿßÿ™ ÿπÿ¥ÿßŸÜ ÿ™ÿ™ÿ£ŸÉŸëÿØ entries ŸÖŸàÿ¨ŸàÿØÿ©
//     return await journalRepo.findOne({
//       where: { id: savedClosing.id },
//       relations: ['entries', 'entries.account', 'entries.costCenter', 'createdBy'],
//     });
//   });
// }


async closeYear(year: number, userId: number | string) {
  return await this.dataSource.transaction(async (manager) => {
    // 1) ÿ¨ŸÑÿ® ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ©
    const fiscalYearRepo = manager.getRepository(FiscalYearEntity);
    const fiscalYear = await fiscalYearRepo.findOne({ where: { year } });
    if (!fiscalYear) throw new NotFoundException(`Fiscal year ${year} not found`);
    if (fiscalYear.isClosed) throw new BadRequestException(`Fiscal year ${year} is already closed`);

    // 2) ÿ™Ÿàÿßÿ±ŸäÿÆ ÿßŸÑÿ≥ŸÜÿ©
    const start = new Date(year, 0, 1);
    const end = new Date(year, 11, 31);

    // 3) ÿßÿ¨ŸÖÿπ ÿ£ÿ±ÿµÿØÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ© (Revenue, Expense)
    const lineQB = manager.getRepository(JournalEntryLineEntity).createQueryBuilder('line')
      .leftJoin('line.journalEntry', 'je')
      .leftJoin('line.account', 'account')
      .select('account.id', 'accountId')
      .addSelect('account.type', 'accountType')
      .addSelect('SUM(line.debit)::numeric', 'sumDebit')
      .addSelect('SUM(line.credit)::numeric', 'sumCredit')
      .where('je.date BETWEEN :start AND :end', { start, end })
      .andWhere('account.type IN (:...types)', { types: [AccountType.Revenue, AccountType.Expense] })
      .groupBy('account.id')
      .addGroupBy('account.type');

    const aggregated: Array<{ accountId: string; accountType: string; sumDebit: string; sumCredit: string; }> =
      await lineQB.getRawMany();

    // 4) ÿ™ÿ£ŸÉÿØ ÿ£Ÿà ÿßŸÜÿ¥ÿ¶ ÿ≠ÿ≥ÿßÿ®ÿßÿ™ Income Summary Ÿà Retained Earnings
    const accountRepo = manager.getRepository(AccountEntity);

    let incomeSummary = await accountRepo.findOne({
      where: [{ name: 'Income Summary' }, { name: 'income_summary' }],
    });
    if (!incomeSummary) {
      incomeSummary = await accountRepo.save(accountRepo.create({
        name: 'Income Summary',
        type: AccountType.Equity,
        accountCode: `9999.${year}`,
        isMain: false,
        isSub: true,
      }));
    }

    let retainedEarnings = await accountRepo.findOne({
      where: [{ name: 'Retained Earnings' }, { name: 'retained_earnings' }],
    });
    if (!retainedEarnings) {
      retainedEarnings = await accountRepo.save(accountRepo.create({
        name: 'Retained Earnings',
        type: AccountType.Equity,
        accountCode: `3000.${year}`,
        isMain: false,
        isSub: true,
      }));
    }

    // 5) ÿ¨Ÿáÿ≤ ÿ£ÿ≥ÿ∑ÿ± ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
    const linesToCreate: JournalEntryLineEntity[] = [];
    let totalRevenue = 0;
    let totalExpense = 0;

    for (const row of aggregated) {
      const accId = Number(row.accountId);
      const sumDebit = Number(row.sumDebit || 0);
      const sumCredit = Number(row.sumCredit || 0);
      const accType = row.accountType as AccountType;

      if (accType === AccountType.Revenue) {
        const revBalance = sumCredit - sumDebit; // ŸÖŸàÿ¨ÿ® = ÿØÿßÿ¶ŸÜ
        if (revBalance !== 0) {
          totalRevenue += revBalance;
          if (revBalance > 0) {
            // ÿ•Ÿäÿ±ÿßÿØ ÿ∑ÿ®ŸäÿπŸä: Debit revenue, Credit Income Summary
            linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
              account: { id: accId } as any,
              debit: revBalance,
              credit: 0,
            }));
            linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
              account: { id: incomeSummary.id } as any,
              debit: 0,
              credit: revBalance,
            }));
          } else {
            const abs = Math.abs(revBalance);
            // ÿ•Ÿäÿ±ÿßÿØ ÿ®ÿ±ÿµŸäÿØ ŸÖÿØŸäŸÜ (ÿπŸÉÿ≥Ÿä): Debit Income Summary, Credit Revenue
            linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
              account: { id: incomeSummary.id } as any,
              debit: abs,
              credit: 0,
            }));
            linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
              account: { id: accId } as any,
              debit: 0,
              credit: abs,
            }));
          }
        }
      } else if (accType === AccountType.Expense) {
        const expBalance = sumDebit - sumCredit; // ŸÖŸàÿ¨ÿ® = ŸÖÿØŸäŸÜ
        if (expBalance !== 0) {
          totalExpense += expBalance;
          if (expBalance > 0) {
            // ŸÖÿµÿ±ŸàŸÅ ÿ∑ÿ®ŸäÿπŸä: Debit Income Summary, Credit Expense
            linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
              account: { id: incomeSummary.id } as any,
              debit: expBalance,
              credit: 0,
            }));
            linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
              account: { id: accId } as any,
              debit: 0,
              credit: expBalance,
            }));
          } else {
            const abs = Math.abs(expBalance);
            // ŸÖÿµÿ±ŸàŸÅ ÿ®ÿ±ÿµŸäÿØ ÿØÿßÿ¶ŸÜ (ÿπŸÉÿ≥Ÿä): Debit Expense, Credit Income Summary
            linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
              account: { id: accId } as any,
              debit: abs,
              credit: 0,
            }));
            linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
              account: { id: incomeSummary.id } as any,
              debit: 0,
              credit: abs,
            }));
          }
        }
      }
    }

    // 6) ÿµÿßŸÅŸä ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© -> Retained Earnings
    const net = totalRevenue - totalExpense;
    if (net > 0) {
      linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
        account: { id: incomeSummary.id } as any,
        debit: net,
        credit: 0,
      }));
      linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
        account: { id: retainedEarnings.id } as any,
        debit: 0,
        credit: net,
      }));
    } else if (net < 0) {
      const abs = Math.abs(net);
      linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
        account: { id: retainedEarnings.id } as any,
        debit: abs,
        credit: 0,
      }));
      linesToCreate.push(manager.getRepository(JournalEntryLineEntity).create({
        account: { id: incomeSummary.id } as any,
        debit: 0,
        credit: abs,
      }));
    }

    // 7) sequenceNumber ŸÑÿ¥Ÿáÿ± ÿØŸäÿ≥ŸÖÿ®ÿ±
    const startDec = new Date(year, 11, 1);
    const endDec = new Date(year, 11, 31);
    const lastDecEntry = await manager.getRepository(JournalEntryEntity)
      .createQueryBuilder('entry')
      .where('entry.date BETWEEN :start AND :end', { start: startDec, end: endDec })
      .orderBy('entry.sequenceNumber', 'DESC')
      .getOne();

    const nextSeq = lastDecEntry ? lastDecEntry.sequenceNumber + 1 : 1;

    // 8) ÿ£ŸÜÿ¥ÿ¶ ŸÇŸäÿØ ÿßŸÑÿ•ŸÇŸÅÿßŸÑ
    const journalRepo = manager.getRepository(JournalEntryEntity);
    const closingEntry = journalRepo.create({
      date: end,
      description: `Closing entries for Fiscal Year ${year}`,
      sequenceNumber: nextSeq,
      code: `${year}-${end.getMonth() + 1}-${nextSeq}`,
      isClosing: true,
      createdBy: { id: userId } as any,
      lastModifiedBy: { id: userId } as any,
      entries: linesToCreate,
    });

    const savedClosing = await journalRepo.save(closingEntry);

    // 9) ÿ∫ŸÑŸÇ ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßŸÑŸäÿ©
    fiscalYear.isClosed = true;
    fiscalYear.closedAt = new Date();
    (fiscalYear as any).closedBy = { id: userId } as any;
    await fiscalYearRepo.save(fiscalYear);

    // 10) ÿ±ÿ¨ÿπ ÿßŸÑŸÇŸäÿØ ŸÖÿπ ÿßŸÑÿπŸÑÿßŸÇÿßÿ™
    return await journalRepo.findOne({
      where: { id: savedClosing.id },
      relations: ['entries', 'entries.account', 'entries.costCenter', 'createdBy'],
    });
  });
}



  // üìå ÿßŸÅÿ™ÿ™ÿßÿ≠ ÿßŸÑÿ≥ŸÜÿ©
  async openYear(newYear: number) {
    let fiscalYear = await this.fiscalYearRepository.findOne({ where: { year: newYear } });

    if (fiscalYear && !fiscalYear.isClosed) {
      throw new BadRequestException(`Fiscal year ${newYear} already open`);
    }

    const prevYear = newYear - 1;
    const endPrev = new Date(`${prevYear}-12-31`);

    const accounts = await this.journalEntryRepository
      .createQueryBuilder('entry')
      .leftJoin('entry.entries', 'line')
      .leftJoin('line.account', 'account')
      .select('account.id', 'accountId')
      .addSelect('SUM(line.debit)', 'debit')
      .addSelect('SUM(line.credit)', 'credit')
      .where('entry.date <= :endPrev', { endPrev })
      .groupBy('account.id')
      .getRawMany();

    if (!accounts.length) {
      throw new NotFoundException(`No balances found for year ${prevYear}`);
    }

    // ŸÇŸäÿØ ÿßŸÑÿßŸÅÿ™ÿ™ÿßÿ≠
    const openingEntry = this.journalEntryRepository.create({
      date: new Date(`${newYear}-01-01`),
      description: `Opening entry for year ${newYear}`,
      entries: await Promise.all(
        accounts.map(async (acc) => {
          const account = await this.accountRepository.findOneByOrFail({
            id: acc.accountId,
          });
          const balance = Number(acc.debit) - Number(acc.credit);
          return this.journalEntryLineRepository.create({
            account,
            debit: balance > 0 ? balance : 0,
            credit: balance < 0 ? -balance : 0,
          });
        }),
      ),
    });

    await this.journalEntryRepository.save(openingEntry);

    // ŸÜÿ∂ŸäŸÅ ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ© ŸÑŸà ŸÖÿ¥ ŸÖŸàÿ¨ŸàÿØÿ©
    if (!fiscalYear) {
      fiscalYear = this.fiscalYearRepository.create({
        year: newYear,
        isClosed: false,
      });
    } else {
      fiscalYear.isClosed = false;
      fiscalYear.closedAt = null;
      fiscalYear.closedBy = null;
    }

    await this.fiscalYearRepository.save(fiscalYear);

    return { message: 'Opening entry created', newYear };
  }


  /**
 * Ÿäÿ≠ÿ≥ÿ® ÿ±ÿµŸäÿØ ÿßŸÑÿ≠ÿ≥ÿßÿ® = SUM(debit) - SUM(credit)
 * @param accountId account id (number|string)
 * @param upTo ÿßÿÆÿ™Ÿäÿßÿ±Ÿä: ÿ™ÿßÿ±ŸäÿÆ ÿ£ŸÇÿµŸâ ŸÑŸÑÿßÿ≠ÿ™ÿ≥ÿßÿ® (inclusive)
 */
async getAccountBalance(accountId: number | string, upTo?: Date): Promise<number> {
  // ÿ™ÿ£ŸÉÿØ ÿ™ÿ≠ŸàŸäŸÑ accountId ŸÑÿ±ŸÇŸÖ (ÿ£Ÿà string ŸÑŸà ÿπŸÜÿØŸÉ UUIDs)
  const accId = typeof accountId === 'string' && /^\d+$/.test(accountId) ? Number(accountId) : accountId;

  const qb = this.journalEntryLineRepository.createQueryBuilder('line')
    .leftJoin('line.journalEntry', 'je')    // ŸÑŸÑÿßÿ∑ŸëŸÑÿßÿπ ÿπŸÑŸâ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸÇŸäÿØ
    .leftJoin('line.account', 'account')    // ŸÑŸÑÿßÿ∑ŸëŸÑÿßÿπ ÿπŸÑŸâ id ÿßŸÑÿ≠ÿ≥ÿßÿ®

    // ŸÅŸÑÿ™ÿ±ÿ© ÿ≠ÿ≥ÿ® ÿ≠ÿ≥ÿßÿ®
    .where('account.id = :accountId', { accountId: accId });

  if (upTo) {
    qb.andWhere('je.date <= :upTo', { upTo });
  }

  const raw = await qb
    .select('COALESCE(SUM(line.debit), 0)', 'debit')
    .addSelect('COALESCE(SUM(line.credit), 0)', 'credit')
    .getRawOne();

  const debit = parseFloat(raw?.debit ?? '0');
  const credit = parseFloat(raw?.credit ?? '0');

  return debit - credit;
}

}
